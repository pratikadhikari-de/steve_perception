# rtabmap_rgbd_commented.ini
#
# RTAB‑Map configuration file with inline comments explaining each parameter.
# Parameter descriptions are based on the official RTAB‑Map documentation and
# source code. See the RTAB‑Map Parameters class reference for details【59428071973660†L1418-L1420】.

# Keyframe / update rate:
# Rtabmap/DetectionRate controls how often RTAB‑Map processes incoming frames. A detection
# rate of 1 Hz means one keyframe per second; 0 disables throttling【59428071973660†L7337-L7341】.
Rtabmap/DetectionRate = 2.0  # detection rate in Hz【59428071973660†L7340-L7341】; higher speeds insert nodes faster but risk warped maps

# Loop closure & graph optimization:
RGBD/OptimizeMaxError = 0.0  # reject loop closures if the optimization error ratio exceeds this threshold; 0 disables the check【59428071973660†L1623-L1627】
RGBD/OptimizeFromGraphEnd = false  # optimize the pose graph from the first node (false) or from the newest node (true)【59428071973660†L1612-L1618】
Mem/STMSize = 30  # short‑term memory size (number of recent nodes kept before moving to working memory); larger values improve loop closure detection
Optimizer\Robust = true  # enable robust graph optimization using the Vertigo algorithm; improves resilience to false loop closures

[Core]
Version = 0.22.1  # RTAB‑Map library version
BRIEF\Bytes = 32  # length of BRIEF descriptors in bytes (16, 32 or 64)【59428071973660†L1418-L1420】
BRISK\Octaves = 3  # number of scale octaves for BRISK keypoint detection【59428071973660†L1418-L1420】
BRISK\PatternScale = 1  # scale applied to the BRISK sampling pattern
BRISK\Thresh = 30  # detection threshold for BRISK (higher→fewer keypoints)
Bayes\FullPredictionUpdate = false  # regenerate full prediction matrix on each iteration (used in appearance‑based loop closure)
Bayes\PredictionLC = 0.1 0.36 0.30 0.16 0.062 0.0151 0.00255 0.000324 2.5e‑05 1.3e‑06 4.8e‑08 1.2e‑09 1.9e‑11 2.2e‑13 1.7e‑15 8.5e‑18 2.9e‑20 6.9e‑23
Bayes\VirtualPlacePriorThr = 0.9  # threshold to consider a virtual place in the Bayes filter
Db\TargetVersion =  # target DB version (leave empty for current)
DbSqlite3\CacheSize = 10000  # size of the SQLite cache【59428071973660†L110-L112】
DbSqlite3\InMemory = false  # store the database in memory instead of on disk【59428071973660†L113-L114】
DbSqlite3\JournalMode = 3  # 0=DELETE,1=TRUNCATE,2=PERSIST,3=MEMORY,4=OFF【59428071973660†L116-L118】
DbSqlite3\Synchronous = 0  # 0=OFF,1=NORMAL,2=FULL【59428071973660†L120-L121】
DbSqlite3\TempStore = 2  # temporary storage: 0=DEFAULT,1=FILE,2=MEMORY【59428071973660†L116-L118】
FAST\CV = 0  # CV version of FAST feature detector (0=OpenCV implementation)
FAST\Gpu = false  # use GPU‑accelerated FAST if available
FAST\GpuKeypointsRatio = 0.05  # ratio of keypoints kept on GPU (0‑1)
FAST\GridCols = 0  # grid columns used to uniformly sample FAST keypoints (0=disabled)
FAST\GridRows = 0  # grid rows used to uniformly sample FAST keypoints (0=disabled)
FAST\MaxThreshold = 200  # maximum threshold for FAST keypoint detection
FAST\MinThreshold = 7  # minimum threshold for FAST keypoint detection
FAST\NonmaxSuppression = true  # whether non‑max suppression is used
FAST\Threshold = 20  # detection threshold for FAST
FREAK\NOctaves = 4  # number of octaves for FREAK descriptor
FREAK\OrientationNormalized = true  # normalize orientation in FREAK descriptors
FREAK\PatternScale = 22  # sampling pattern scale for FREAK
FREAK\ScaleNormalized = true  # normalize scale in FREAK descriptors
GFTT\BlockSize = 3  # block size for GoodFeaturesToTrack (GFTT)
GFTT\Gpu = false  # use GPU version for GFTT
GFTT\K = 0.04  # Harris corner detector parameter k
GFTT\MinDistance = 7  # minimum distance between keypoints for GFTT
GFTT\QualityLevel = 0.001  # quality level threshold for GFTT
GFTT\UseHarrisDetector = false  # use the Harris detector variant in GFTT
GMS\ThresholdFactor = 6.0  # threshold factor for GMS matching
GMS\WithRotation = false  # enable rotation consistency in GMS
GMS\WithScale = false  # enable scale consistency in GMS
GTSAM\IncRelinearizeSkip = 1  # how many iterations to skip before relinearization in GTSAM
GTSAM\IncRelinearizeThreshold = 0.01  # threshold for incremental relinearization in GTSAM
GTSAM\Incremental = false  # use incremental mode in GTSAM
GTSAM\Optimizer = 1  # optimization method in GTSAM (1=Levenberg–Marquardt)
Grid\3D = true  # create a 3D occupancy grid
Grid\CellSize = 0.05  # resolution (m) of the occupancy grid
Grid\ClusterRadius = 0.1  # radius to cluster obstacles into voxels
Grid\DepthDecimation = 4  # depth image decimation factor before grid extraction
Grid\DepthRoiRatios = 0.0 0.0 0.0 0.0  # ROI ratios for depth data cropping
Grid\FlatObstacleDetected = true  # detect flat obstacles from the point cloud
Grid\FootprintHeight = 0.0  # robot footprint height used to ignore low obstacles
Grid\FootprintLength = 0.0  # robot footprint length used to ignore obstacles within footprint
Grid\FootprintWidth = 0.0  # robot footprint width used to ignore obstacles within footprint
Grid\GroundIsObstacle = false  # treat ground as an obstacle
Grid\MapFrameProjection = false  # project map frame to the grid
Grid\MaxGroundAngle = 45  # max slope angle considered as ground (degrees)
Grid\MaxGroundHeight = 0.0  # maximum height considered as ground
Grid\MaxObstacleHeight = 0.0  # maximum height for an obstacle (0=inf)
Grid\MinClusterSize = 10  # minimum cluster size to keep in occupancy grid
Grid\MinGroundHeight = 0.0  # minimum height considered as ground
Grid\NoiseFilteringMinNeighbors = 5  # minimum neighbors to keep a point in noise filtering
Grid\NoiseFilteringRadius = 0.0  # radius for neighbor search in noise filtering
Grid\NormalK = 20  # number of nearest neighbors for normal estimation
Grid\NormalsSegmentation = true  # use normals to segment ground and obstacles
Grid\PreVoxelFiltering = true  # enable voxel downsampling before grid extraction
Grid\RangeMax = 5.0  # maximum sensor range considered in the grid (m)
Grid\RangeMin = 0.0  # minimum sensor range considered
Grid\RayTracing = false  # perform ray tracing for occupancy grid
Grid\Scan2dUnknownSpaceFilled = false  # fill unknown space in 2D scans
Grid\ScanDecimation = 1  # decimation factor for 2D scan points
Grid\Sensor = 1  # input sensor type (0=laser,1=depth image,2=stereo)
GridGlobal\AltitudeDelta = 0  # altitude difference considered for merging scans
GridGlobal\Eroded = false  # erode global grid after update
GridGlobal\FloodFillDepth = 0  # flood fill depth for global occupancy grid
GridGlobal\FootprintRadius = 0.0  # radius of robot footprint used for global grid
GridGlobal\MaxNodes = 0  # maximum nodes kept in global grid (0=inf)
GridGlobal\MinSize = 0.0  # minimum map size before saving
GridGlobal\OccupancyThr = 0.5  # occupancy probability threshold (0‑1)
GridGlobal\ProbClampingMax = 0.971  # maximum clamped occupancy probability【59428071973660†L1612-L1618】
GridGlobal\ProbClampingMin = 0.1192  # minimum clamped occupancy probability【59428071973660†L1612-L1618】
GridGlobal\ProbHit = 0.7  # probability of occupancy given a hit
GridGlobal\ProbMiss = 0.4  # probability of occupancy given a miss
GridGlobal\UpdateError = 0.01  # update error factor for Bayesian occupancy filter
Icp\CCFilterOutFarthestPoints = false  # filter farthest correspondences in ICP
Icp\CCMaxFinalRMS = 0.2  # ICP RMS threshold to accept correspondences
Icp\CCSamplingLimit = 50000  # maximum sampled correspondences in ICP
Icp\CorrespondenceRatio = 0.1  # ratio of top correspondences used in ICP
Icp\DebugExportFormat =  # export debug information (none=disabled)
Icp\DownsamplingStep = 1  # downsampling step for point clouds before ICP
Icp\Epsilon = 0  # epsilon convergence threshold for ICP
Icp\FiltersEnabled = 3  # bitmask enabling ICP filters (1=voxel,2=median,4=ratio)
Icp\Force4DoF = false  # force ICP to compute 4DoF (x,y,z,yaw) transforms
Icp\Iterations = 30  # maximum iterations for ICP
Icp\MaxCorrespondenceDistance = 0.1  # maximum distance between correspondences in ICP
Icp\MaxRotation = 0.78  # maximum rotation allowed between frames (rad) in ICP
Icp\MaxTranslation = 0.2  # maximum translation allowed between frames (m) in ICP
Icp\OutlierRatio = 0.85  # ratio of outliers allowed before rejecting ICP
Icp\PMConfig =  # point matcher configuration file path
Icp\PMMatcherEpsilon = 0.0  # epsilon for point matcher (unused)
Icp\PMMatcherIntensity = false  # use intensity difference for matching points
Icp\PMMatcherKnn = 1  # nearest neighbors used in point matcher
Icp\PointToPlane = true  # use point‑to‑plane metric instead of point‑to‑point
Icp\PointToPlaneGroundNormalsUp = 0.0  # weight for ground normals to bias plane orientation
Icp\PointToPlaneK = 5  # nearest neighbors used for plane fitting
Icp\PointToPlaneLowComplexityStrategy = 1  # 0=disabled,1=use normals precomputed by grid
Icp\PointToPlaneMinComplexity = 0.02  # minimum complexity to be considered a plane
Icp\PointToPlaneRadius = 0.0  # search radius for plane fitting (0=automatic)
Icp\RangeMax = 0  # maximum range used for ICP (0=disabled)
Icp\RangeMin = 0  # minimum range used for ICP
Icp\ReciprocalCorrespondences = true  # only accept correspondences reciprocal between clouds
Icp\Strategy = 1  # ICP strategy (0=point‑to‑point,1=point‑to‑plane,2=libpointmatcher)
Icp\VoxelSize = 0.05  # voxel size for downsampling point clouds before ICP
ImuFilter\ComplementaryBiasAlpha = 0.01  # bias adaptation factor in complementary filter
ImuFilter\ComplementaryDoAdpativeGain = true  # adaptive gain in complementary filter
ImuFilter\ComplementaryDoBiasEstimation = true  # estimate bias in complementary filter
ImuFilter\ComplementaryGainAcc = 0.01  # complementary filter gain for accelerometer
ImuFilter\MadgwickGain = 0.1  # gain for Madgwick filter
ImuFilter\MadgwickZeta = 0.0  # drift correction factor for Madgwick filter
KAZE\Diffusivity = 1  # diffusion type for KAZE (1=Perona & Malik, 2=constant, 3=flow based)
KAZE\Extended = false  # use extended 128‑byte KAZE descriptors
KAZE\NOctaveLayers = 4  # number of layers per octave in KAZE
KAZE\NOctaves = 4  # number of octaves in KAZE
KAZE\Threshold = 0.001  # threshold for KAZE feature detection
KAZE\Upright = false  # compute upright KAZE descriptors (no orientation)
Kp\BadSignRatio = 0.5  # threshold ratio for bad signatures (appearance based)
Kp\ByteToFloat = false  # convert descriptors to float (saves memory)
Kp\DetectorStrategy = 8  # feature detector strategy: 0=SURF,1=SIFT,2=ORB,3=FAST/FREAK,4=FAST/BRIEF,5=GFTT/FREAK,6=GFTT/BRIEF,7=BRISK,8=GFTT/ORB,9=KAZE,10=ORB‑OCTREE,11=SuperPoint,12=SURF/FREAK,13=GFTT/DAISY,14=SURF/DAISY,15=PyDetector【59428071973660†L538-L542】
Kp\DictionaryPath =  # path to vocabulary file used for bag‑of‑words dictionary
Kp\FlannRebalancingFactor = 2.0  # factor to trigger FLANN index rebuild【59428071973660†L544-L562】
Kp\GridCols = 1  # number of columns in feature extraction grid【59428071973660†L548-L554】
Kp\GridRows = 1  # number of rows in feature extraction grid【59428071973660†L548-L554】
Kp\IncrementalDictionary = true  # build the visual dictionary incrementally
Kp\IncrementalFlann = true  # update FLANN index incrementally【59428071973660†L558-L562】
Kp\MaxDepth = 0  # maximum depth of keypoints (0=inf)【59428071973660†L564-L565】
Kp\MaxFeatures = 500  # maximum number of features per image【59428071973660†L567-L568】
Kp\MinDepth = 0  # minimum depth of keypoints【59428071973660†L571-L572】
Kp\NNStrategy = 1  # nearest‑neighbor search strategy: 0=FlannNaive,1=FlannKdTree,2=FlannLSH,3=BruteForce,4=BruteForceGPU【59428071973660†L582-L584】
Kp\NewWordsComparedTogether = true  # compare new dictionary words together【59428071973660†L574-L576】
Kp\NndrRatio = 0.8  # nearest neighbor distance ratio for descriptor matching【59428071973660†L578-L580】
Kp\Parallelized = true  # parallelize dictionary update and signature creation【59428071973660†L585-L587】
Kp\RoiRatios = 0.0 0.0 0.0 0.0  # region‑of‑interest cropping ratios for keypoint extraction
Kp\SSC = false  # apply Suppression via Square Covering to limit keypoints【59428071973660†L588-L589】
Kp\SubPixEps = 0.02  # subpixel corner refinement epsilon【59428071973660†L590-L592】
Kp\SubPixIterations = 0  # number of iterations for subpixel corner refinement【59428071973660†L590-L592】
Kp\SubPixWinSize = 3  # window size for subpixel corner refinement【59428071973660†L590-L592】
Kp\TfIdfLikelihoodUsed = true  # use tf‑idf weighting for likelihood calculation【59428071973660†L599-L600】
Marker\CornerRefinementMethod = 0  # method for ArUco marker corner refinement: 0=None,1=Subpixel,2=Contour,3=AprilTag2【59428071973660†L603-L605】
Marker\Dictionary = 0  # marker dictionary: DICT_ARUCO_4X4_50=0,...,DICT_APRILTAG_36h11=20【59428071973660†L607-L614】
Marker\Length = 0  # marker side length in meters (0=auto estimated)【59428071973660†L616-L619】
Marker\MaxDepthError = 0.01  # maximum depth error accepted for marker detection【59428071973660†L621-L622】
Marker\MaxRange = 0.0  # maximum range for marker detection (0=disabled)
Marker\MinRange = 0.0  # minimum range for marker detection
Marker\Priors =  # user‑defined marker priors (format id:x y z roll pitch yaw)
Marker\PriorsVarianceAngular = 0.001  # variance of angular priors (rad²)
Marker\PriorsVarianceLinear = 0.001  # variance of linear priors (m²)
Marker\VarianceAngular = 0.01  # variance used for marker angular measurement
Marker\VarianceLinear = 0.001  # variance used for marker linear measurement
Marker\VarianceOrientationIgnored = false  # ignore marker orientation in optimization
Mem\BadSignaturesIgnored = false  # ignore bad signatures when calculating likelihood
Mem\BinDataKept = true  # keep binned data in the database for LTM
Mem\CompressionParallelized = true  # compress images/depth data in parallel
Mem\CovOffDiagIgnored = true  # ignore off‑diagonal covariance entries
Mem\DepthAsMask = true  # treat depth images as masks (non‑zero depth = valid pixel)
Mem\DepthCompressionFormat = .rvl  # depth compression format (.png,.rvl,.zip)
Mem\DepthMaskFloorThr = 0.0  # floor depth threshold to mark invalid depth
Mem\GenerateIds = true  # generate unique location IDs when adding signatures
Mem\GlobalDescriptorStrategy = 0  # global descriptor strategy (0=disabled,1=BRIEF,2=ORB,...)
Mem\ImageCompressionFormat = .jpg  # format for storing color images
Mem\ImageKept = false  # keep original color images in database
Mem\ImagePostDecimation = 1  # downsample color image after compression
Mem\ImagePreDecimation = 1  # downsample color image before compression
Mem\IncrementalMemory = true  # enable incremental memory (WM/LTM separation)
Mem\InitWMWithAllNodes = false  # initialize working memory with all nodes on database load
Mem\IntermediateNodeDataKept = false  # keep intermediate data for local bundle adjustment
Mem\LaserScanDownsampleStepSize = 1  # step size for downsampling laser scans
Mem\LaserScanNormalK = 0  # neighbor count for laser scan normal estimation
Mem\LaserScanNormalRadius = 0.0  # search radius for laser scan normal estimation (0=auto)
Mem\LaserScanVoxelSize = 0.0  # voxel size for downsampling laser scan (0=no voxelization)
Mem\LocalizationDataSaved = false  # save localization sessions to database
Mem\MapLabelsAdded = true  # add default labels to the map (e.g., loop closures)
Mem\NotLinkedNodesKept = true  # keep nodes that are not linked by constraints
Mem\RawDescriptorsKept = true  # keep raw descriptors in the database
Mem\RecentWmRatio = 0.2  # ratio of recent nodes kept in working memory when transferring to LTM
Mem\ReduceGraph = false  # reduce graph complexity when nodes are transferred to LTM
Mem\RehearsalIdUpdatedToNewOne = false  # update old node ID to the new node ID on rehearsal
Mem\RehearsalSimilarity = 0.6  # similarity threshold for rehearsal (visual similarity)
Mem\RehearsalWeightIgnoredWhileMoving = false  # ignore rehearsal weight when robot is moving
Mem\RotateImagesUpsideUp = false  # rotate images upright before feature extraction
Mem\STMSize = 30  # short‑term memory size (duplicate; see earlier comment)
Mem\SaveDepth16Format = false  # save 16‑bit depth images (.png) instead of 8‑bit
Mem\StereoFromMotion = false  # generate stereo from motion (monocular) using odometry
Mem\TransferSortingByWeightId = false  # sort nodes by weight when transferring to LTM
Mem\UseOdomFeatures = true  # use odometry features to generate constraints
Mem\UseOdomGravity = false  # use gravity information from odometry (IMU)
ORB\EdgeThreshold = 19  # size of border where features are not detected (must match patch size)【59428071973660†L1426-L1429】
ORB\FirstLevel = 0  # first pyramid level used by ORB (0=base level)【59428071973660†L1430-L1431】
ORB\Gpu = false  # use GPU implementation of ORB if available【59428071973660†L1433-L1435】
ORB\NLevels = 3  # number of pyramid levels for ORB【59428071973660†L1437-L1439】
ORB\PatchSize = 31  # patch size for BRIEF in ORB【59428071973660†L1441-L1442】
ORB\ScaleFactor = 2  # pyramid decimation ratio (>1); 2 means each level has 1/4 pixels【59428071973660†L1445-L1451】
ORB\ScoreType = 0  # scoring type: 0=HARRIS_SCORE,1=FAST_SCORE【59428071973660†L1453-L1457】
ORB\WTA_K = 2  # number of points per BRIEF element (2,3 or 4)【59428071973660†L1459-L1471】
Optimizer\Epsilon = 0.00001  # convergence threshold for graph optimizer
Optimizer\GravitySigma = 0.3  # sigma for gravity noise in graph optimizer
Optimizer\Iterations = 20  # max iterations for graph optimization
Optimizer\LandmarksIgnored = false  # ignore landmark constraints in optimization【59428071973660†L1421-L1423】
Optimizer\PriorsIgnored = true  # ignore prior constraints in optimization
Optimizer\Robust = true  # enable robust optimization (Vertigo)
Optimizer\Strategy = 2  # graph optimization backend: 0=TORO,1=g2o,2=GTSAM,3=Ceres【59428071973660†L1418-L1420】
Optimizer\VarianceIgnored = false  # ignore constraint variance (use identity information matrix)【59428071973660†L1421-L1424】
PyDescriptor\Dim = 4096  # dimension of the neural descriptor used by SuperPoint/SuperGlue【59428071973660†L1473-L1475】
PyDescriptor\Path =  # path to descriptor model
PyDetector\Cuda = true  # use CUDA for PyTorch detector
PyDetector\Path =  # path to detector model (e.g., SuperPoint)
PyMatcher\Cuda = true  # use CUDA for PyTorch matcher (SuperGlue)
PyMatcher\Iterations = 20  # number of Sinkhorn iterations in SuperGlue【59428071973660†L1481-L1483】
PyMatcher\Model = indoor  # pre‑trained model for SuperGlue (indoor, outdoor)
PyMatcher\Path =  # path to matcher model
PyMatcher\Threshold = 0.2  # matching threshold in SuperGlue【59428071973660†L1484-L1485】
RGBD\AggressiveLoopThr = 0.05  # threshold used to aggressively close loops when starting a new map【59428071973660†L1499-L1505】
RGBD\AngularSpeedUpdate = 0.0  # maximum angular speed (rad/s) to update the map (0=no limit)【59428071973660†L1509-L1511】
RGBD\AngularUpdate = 0.1  # minimum angular displacement (rad) to update the map【59428071973660†L1513-L1515】
RGBD\CreateOccupancyGrid = true  # create local occupancy grid maps【59428071973660†L1517-L1519】
RGBD\Enabled = true  # enable metric RGB‑D SLAM (false = appearance‑only loop closure)【59428071973660†L1520-L1523】
RGBD\ForceOdom3DoF = true  # force odometry poses to be 3DoF if Reg\Force3DoF is true【59428071973660†L1524-L1526】
RGBD\GoalReachedRadius = 0.5  # radius within which a goal is considered reached【59428071973660†L1528-L1533】
RGBD\GoalsSavedInUserData = false  # save goals in node’s user data【59428071973660†L1531-L1533】
RGBD\InvertedReg = false  # invert registration direction for loop closures【59428071973660†L1535-L1537】
RGBD\LinearSpeedUpdate = 0.0  # maximum linear speed (m/s) to update the map (0=no limit)【59428071973660†L1539-L1541】
RGBD\LinearUpdate = 0.1  # minimum linear displacement (m) to update the map【59428071973660†L1542-L1544】
RGBD\LocalBundleOnLoopClosure = false  # do local bundle adjustment around loop closures【59428071973660†L1546-L1547】
RGBD\LocalImmunizationRatio = 0.25  # ratio of working memory immunized from transfer【59428071973660†L1549-L1551】
RGBD\LocalRadius = 10  # radius (m) for selecting nodes in local map【59428071973660†L1561-L1563】
RGBD\LocalizationPriorError = 0.001  # variance assigned to priors during localization【59428071973660†L1552-L1555】
RGBD\LocalizationSecondTryWithoutProximityLinks = true  # try localization again without proximity links
RGBD\LocalizationSmoothing = true  # adjust localization constraints using smoothed odometry【59428071973660†L1556-L1559】
RGBD\LoopClosureIdentityGuess = false  # use identity matrix as guess for loop closure transform【59428071973660†L1565-L1569】
RGBD\LoopClosureReextractFeatures = false  # re‑extract features for loop closure candidates【59428071973660†L1571-L1573】
RGBD\LoopCovLimited = false  # limit covariance of loop closures to nearest odometry covariance【59428071973660†L1575-L1579】
RGBD\MarkerDetection = false  # detect static markers as landmarks【59428071973660†L1581-L1584】
RGBD\MaxLocalRetrieved = 2  # max number of local locations retrieved near current pose【59428071973660†L1586-L1589】
RGBD\MaxLoopClosureDistance = 0.0  # maximum distance from map for accepting a loop closure (0=disabled)【59428071973660†L1591-L1594】
RGBD\MaxOdomCacheSize = 10  # odometry cache size for smoothing localization【59428071973660†L1595-L1601】
RGBD\NeighborLinkRefining = false  # refine neighbor link using registration when adding a new node【59428071973660†L1603-L1606】
RGBD\NewMapOdomChangeDistance = 0  # create new map if odometry jump exceeds this distance【59428071973660†L1608-L1611】
RGBD\OptimizeFromGraphEnd = false  # duplicate of earlier; optimize from oldest node【59428071973660†L1612-L1618】
RGBD\OptimizeMaxError = 0.1  # threshold to reject loop closures by error ratio【59428071973660†L1623-L1627】
RGBD\PlanAngularVelocity = 0  # angular velocity used for planning weights【59428071973660†L1629-L1630】
RGBD\PlanLinearVelocity = 0  # linear velocity used for planning weights【59428071973660†L1632-L1633】
RGBD\PlanStuckIterations = 0  # number of iterations before a goal is considered stuck【59428071973660†L1635-L1637】
RGBD\ProximityAngle = 45  # max angle difference (deg) for proximity detection【59428071973660†L1640-L1641】
RGBD\ProximityBySpace = true  # detect proximity by spatial distance【59428071973660†L1643-L1645】
RGBD\ProximityByTime = false  # detect proximity by temporal distance【59428071973660†L1646-L1647】
RGBD\ProximityGlobalScanMap = false  # use global assembled scans for one‑to‑many proximity【59428071973660†L1649-L1658】
RGBD\ProximityMaxGraphDepth = 50  # maximum depth from current location considered in proximity detection【59428071973660†L1660-L1662】
RGBD\ProximityMaxPaths = 3  # maximum number of paths compared for proximity detection【59428071973660†L1664-L1666】
RGBD\ProximityMergedScanCovFactor = 100.0  # covariance scaling factor when merging scans
RGBD\ProximityOdomGuess = false  # use odometry guess for proximity detection
RGBD\ProximityPathFilteringRadius = 1  # radius (m) for filtering paths in proximity detection
RGBD\ProximityPathMaxNeighbors = 0  # max neighbors considered in path filtering
RGBD\ProximityPathRawPosesUsed = true  # use raw odometry poses for path filtering
RGBD\ScanMatchingIdsSavedInLinks = true  # save scan matching ids in constraints
RGBD\StartAtOrigin = false  # start the map at the origin (false uses first pose)
Reg\Force3DoF = false  # force registration to compute 3DoF transforms【59428071973660†L1487-L1489】
Reg\RepeatOnce = true  # perform registration twice using the first result as guess【59428071973660†L1491-L1495】
Reg\Strategy = 0  # registration strategy: 0=Vis (visual),1=Icp,2=VisIcp【59428071973660†L1496-L1498】
Rtabmap\ComputeRMSE = true  # compute root mean square error when optimizing
Rtabmap\CreateIntermediateNodes = false  # create intermediate nodes when odometry update is below thresholds
Rtabmap\DetectionRate = 2  # detection rate in Hz (duplicate; see earlier)【59428071973660†L7337-L7341】
Rtabmap\ImageBufferSize = 1  # buffer size for incoming data【59428071973660†L7350-L7352】
Rtabmap\ImagesAlreadyRectified = true  # images are already rectified; false means RTAB‑Map will rectify【59428071973660†L7358-L7363】
Rtabmap\LoopGPS = true  # use GPS to filter loop closures【59428071973660†L7373-L7377】
Rtabmap\LoopRatio = 0  # loop closure acceptance ratio relative to last hypothesis【59428071973660†L7383-L7387】
Rtabmap\LoopThr = 0.11  # loop closure likelihood threshold【59428071973660†L7394-L7397】
Rtabmap\MaxRepublished = 2  # maximum nodes republished when data are missing【59428071973660†L7404-L7411】
Rtabmap\MaxRetrieved = 2  # maximum nodes retrieved at once【59428071973660†L7417-L7422】
Rtabmap\MemoryThr = 0  # maximum nodes in working memory before transferring to LTM【59428071973660†L7429-L7435】
Rtabmap\PublishLastSignature = true  # publish the last signature (node)【59428071973660†L7441-L7445】
Rtabmap\PublishLikelihood = true  # publish likelihood values【59428071973660†L7451-L7455】
Rtabmap\PublishPdf = true  # publish loop closure pdf【59428071973660†L7462-L7466】
Rtabmap\PublishRAMUsage = false  # publish RAM usage in statistics【59428071973660†L7472-L7476】
Rtabmap\PublishStats = true  # publish statistics【59428071973660†L7482-L7486】
Rtabmap\RectifyOnlyFeatures = false  # rectify only feature points, not full images【59428071973660†L7472-L7476】
Rtabmap\SaveWMState = false  # save working memory state with database
Rtabmap\StartNewMapOnGoodSignature = false  # start new map if a good signature is detected
Rtabmap\StartNewMapOnLoopClosure = false  # start new map on loop closure
Rtabmap\StatisticLogged = false  # log statistics to file
Rtabmap\StatisticLoggedHeaders = true  # log statistic headers in file
Rtabmap\StatisticLogsBufferedInRAM = true  # buffer statistic logs in RAM before writing
Rtabmap\TimeThr = 0  # maximum time (s) in working memory before transferring to LTM
Rtabmap\VirtualPlaceLikelihoodRatio = 0  # ratio to consider a location as virtual
Rtabmap\WorkingDirectory = /home/pratik/.ros  # working directory where database is saved
SIFT\ContrastThreshold = 0.04  # contrast threshold for SIFT feature detection
SIFT\EdgeThreshold = 10  # edge threshold for SIFT
SIFT\GaussianThreshold = 2.0  # gaussian blur threshold for SIFT
SIFT\Gpu = false  # use GPU acceleration for SIFT
SIFT\NOctaveLayers = 3  # number of layers in each octave for SIFT
SIFT\PreciseUpscale = false  # precise upscale computation for SIFT
SIFT\RootSIFT = false  # use root‑normalized SIFT descriptors
SIFT\Sigma = 1.6  # gaussian sigma for SIFT
SIFT\Upscale = false  # upscale images for SIFT
SURF\Extended = false  # use extended 128‑element SURF descriptors
SURF\GpuKeypointsRatio = 0.01  # ratio of SURF keypoints computed on GPU
SURF\GpuVersion = false  # use GPU implementation of SURF
SURF\HessianThreshold = 500  # hessian threshold for SURF detection (higher → fewer features)
SURF\OctaveLayers = 2  # number of layers in each octave for SURF
SURF\Octaves = 4  # number of octaves for SURF
SURF\Upright = false  # compute upright SURF descriptors (no rotation)
Stereo\DenseStrategy = 0  # dense stereo matching strategy: 0=BM,1=SGBM,2=libELAS
Stereo\Eps = 0.01  # epsilon stopping criterion for disparity refinement
Stereo\Gpu = false  # use GPU for stereo processing
Stereo\Iterations = 30  # number of iterations for disparity refinement
Stereo\MaxDisparity = 128.0  # maximum disparity (pixels) for stereo
Stereo\MaxLevel = 5  # number of pyramid levels for stereo
Stereo\MinDisparity = 0.5  # minimum disparity considered for stereo
Stereo\OpticalFlow = true  # use optical flow to initialize stereo disparity
Stereo\SSD = true  # use sum‑of‑squared‑differences for stereo block matching
Stereo\WinHeight = 3  # block matching window height
Stereo\WinWidth = 15  # block matching window width
StereoBM\BlockSize = 15  # block size for stereo BM
StereoBM\Disp12MaxDiff = -1  # maximum allowed difference in left‑right disparity (-1=disabled)
StereoBM\MinDisparity = 0  # minimum disparity for stereo BM
StereoBM\NumDisparities = 128  # number of disparity levels (must be multiple of 16)
StereoBM\PreFilterCap = 31  # pre‑filter cap for stereo BM
StereoBM\PreFilterSize = 9  # pre‑filter size for stereo BM
StereoBM\SpeckleRange = 4  # maximum disparity variation within connected components
StereoBM\SpeckleWindowSize = 100  # maximum size of speckle regions removed in disparity
StereoBM\TextureThreshold = 10  # texture threshold for stereo BM
StereoBM\UniquenessRatio = 15  # uniqueness ratio for stereo BM
StereoSGBM\BlockSize = 15  # block size for stereo SGBM
StereoSGBM\Disp12MaxDiff = 1  # maximum allowed left‑right disparity difference
StereoSGBM\MinDisparity = 0  # minimum disparity for SGBM
StereoSGBM\Mode = 2  # SGBM mode (0=full DP,1=hierarchical,2=3‑way)
StereoSGBM\NumDisparities = 128  # number of disparities for SGBM (multiple of 16)
StereoSGBM\P1 = 2  # penalty for small disparity change (smoothness)
StereoSGBM\P2 = 5  # penalty for large disparity change (smoothness)
StereoSGBM\PreFilterCap = 31  # pre‑filter cap for SGBM
StereoSGBM\SpeckleRange = 4  # disparity variation for speckle removal
StereoSGBM\SpeckleWindowSize = 100  # speckle window size for SGBM
StereoSGBM\UniquenessRatio = 20  # uniqueness ratio for SGBM
SuperPoint\Cuda = true  # use CUDA for SuperPoint network
SuperPoint\ModelPath =  # path to SuperPoint model file
SuperPoint\NMS = true  # enable Non‑Maximum Suppression for SuperPoint
SuperPoint\NMSRadius = 4  # radius for NMS
SuperPoint\Threshold = 0.010  # detection threshold for SuperPoint
VhEp\Enabled = false  # enable epipolar verification for vertical/horizontal edges
VhEp\MatchCountMin = 8  # minimum matches for VhEp
VhEp\RansacParam1 = 3  # RANSAC reprojection error threshold (pixels)
VhEp\RansacParam2 = 0.99  # RANSAC confidence
Vis\BundleAdjustment = 1  # global bundle adjustment backend: 0=G2O,1=g2o (Ceres?),2=GTSAM
Vis\CorFlowEps = 0.01  # optical flow termination epsilon
Vis\CorFlowGpu = false  # use GPU for optical flow
Vis\CorFlowIterations = 30  # iterations for optical flow
Vis\CorFlowMaxLevel = 3  # maximum pyramid level for optical flow
Vis\CorFlowWinSize = 16  # window size for optical flow
Vis\CorGuessMatchToProjection = false  # match correspondences by projecting guess
Vis\CorGuessWinSize = 40  # guess search window size
Vis\CorNNDR = 0.8  # nearest neighbor distance ratio for matching
Vis\CorNNType = 1  # nearest neighbor type: 0=FLANN,1=BF,2=SuperGlue
Vis\CorType = 0  # correspondence type: 0=Feature2D,1=OpticalFlow
Vis\DepthAsMask = true  # use depth as mask in visual odometry
Vis\DepthMaskFloorThr = 0.0  # floor depth threshold for mask
Vis\EpipolarGeometryVar = 0.1  # epipolar geometry variance threshold
Vis\EstimationType = 1  # pose estimation type: 0=PnP,1=EPNP,2=UPnP
Vis\FeatureType = 8  # feature type (same enumeration as Kp\DetectorStrategy)【59428071973660†L538-L542】
Vis\GridCols = 1  # grid columns for feature extraction
Vis\GridRows = 1  # grid rows for feature extraction
Vis\InlierDistance = 0.1  # maximum inlier distance for pose estimation
Vis\Iterations = 300  # max iterations for visual pose estimation
Vis\MaxDepth = 0  # maximum depth used for visual odometry (0=inf)
Vis\MaxFeatures = 1000  # maximum features used in visual odometry
Vis\MeanInliersDistance = 0.0  # mean inliers distance threshold
Vis\MinDepth = 0  # minimum depth used
Vis\MinInliers = 20  # minimum number of inliers for pose estimation
Vis\MinInliersDistribution = 0.0  # minimum distribution of inliers across grid
Vis\PnPFlags = 0  # flags for cv::solvePnP (0=ITERATIVE)
Vis\PnPMaxVariance = 0.0  # maximum variance accepted for PnP
Vis\PnPRefineIterations = 0  # refine iterations for PnP
Vis\PnPReprojError = 2  # reprojection error for PnP (pixels)
Vis\PnPSamplingPolicy = 1  # sampling policy for PnP (1=random,2=deterministic)
Vis\PnPSplitLinearCovComponents = false  # split covariance components in PnP
Vis\PnPVarianceMedianRatio = 4  # ratio to switch from median to mean variance
Vis\RefineIterations = 5  # global pose refinement iterations
Vis\RoiRatios = 0.0 0.0 0.0 0.0  # ROI cropping ratios for visual odometry
Vis\SSC = false  # apply SSC to limit features in visual odometry
Vis\SubPixEps = 0.02  # epsilon for sub‑pixel refinement
Vis\SubPixIterations = 0  # iterations for sub‑pixel refinement
Vis\SubPixWinSize = 3  # window size for sub‑pixel refinement
g2o\Baseline = 0.075  # baseline between stereo cameras used by g2o
g2o\Optimizer = 0  # g2o optimizer type: 0=Levenberg,1=Gauss‑Newton【59428071973660†L1418-L1420】
g2o\PixelVariance = 1.0  # pixel variance used in g2o optimization
g2o\RobustKernelDelta = 8  # delta for robust kernel in g2o
g2o\Solver = 0  # g2o solver: 0=csparse,1=pcg,2=cholmod【59428071973660†L1418-L1420】